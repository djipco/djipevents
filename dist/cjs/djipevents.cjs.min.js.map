{"version":3,"file":"djipevents.cjs.min.js","sources":["../../src/djipevents.js"],"sourcesContent":["/**\n * The `EventEmitter` class provides methods to implement the _observable_ design pattern. This\n * pattern allows one to _register_ a function to execute when a specific event is _emitted_ by the\n * emitter.\n *\n * It is intended to be an abstract class meant to be extended by (or mixed into) other objects.\n */\nexport class EventEmitter {\n\n  /**\n   * Creates a new `EventEmitter`object.\n   *\n   * @param {boolean} [eventsSuspended=false] Whether the `EventEmitter` is initially in a suspended\n   * state (i.e. not executing callbacks).\n   */\n  constructor(eventsSuspended = false) {\n\n    /**\n     * An object containing a property for each event with at least one registered listener. Each\n     * event property contains an array of all the [`Listener`]{@link Listener} objects registered\n     * for the event.\n     *\n     * @type {Object}\n     * @readonly\n     */\n    this.eventMap = {};\n\n    /**\n     * Whether or not the execution of callbacks is currently suspended for this emitter.\n     *\n     * @type {boolean}\n     */\n    this.eventsSuspended = eventsSuspended == true ? true : false;\n\n  }\n\n  /**\n   * The callback function is executed when the associated event is triggered via [`emit()`](#emit).\n   * The [`emit()`](#emit) method relays all additional arguments it received to the callback\n   * functions. Since [`emit()`](#emit) can be passed a variable number of arguments, it is up to\n   * the developer to make sure the arguments match those of the associated callback. In addition,\n   * the callback also separately receives all the arguments present in the listener's\n   * [`arguments`](Listener#arguments) property. This makes it easy to pass data from where the\n   * listener is added to where the listener is executed.\n   *\n   * @callback EventEmitter~callback\n   * @param {...*} [args] A variable number of arguments matching the ones (if any) that were passed\n   * to the [`emit()`](#emit) method (except, the first one) followed by the arguments found in the\n   * listener's [`arguments`](Listener#arguments) array.\n   */\n\n  /**\n   * Adds a listener for the specified event. It returns the [`Listener`]{@link Listener} object\n   * that was created and attached to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use\n   * [`EventEmitter.ANY_EVENT`]{@link #ANY_EVENT} as the first parameter. Note that a global\n   * listener will also be triggered by non-registered events.\n   *\n   * @param {string|Symbol} event The event to listen to.\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs.\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The value of `this` in the callback function.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array and thus executed first.\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {number} [options.remaining=Infinity] The number of times after which the callback\n   * should automatically be removed.\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the [`arguments`]{@link Listener#arguments}\n   * property of the [`Listener`]{@link Listener} object and can be retrieved or modified as\n   * desired.\n   *\n   * @returns {Listener} The newly created [`Listener`]{@link Listener} object.\n   *\n   * @throws {TypeError} The `event` parameter must be a string or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.\n   * @throws {TypeError} The `callback` parameter must be a function.\n   */\n  addListener(event, callback, options = {}) {\n\n    if (\n      (typeof event === \"string\" && event.length < 1) ||\n      (event instanceof String && event.length < 1) ||\n      (typeof event !== \"string\" && !(event instanceof String) && event !== EventEmitter.ANY_EVENT)\n    ) {\n      throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");\n    }\n\n    if (typeof callback !== \"function\") throw new TypeError(\"The callback must be a function.\");\n\n    const listener = new Listener(event, this, callback, options);\n\n    if (!this.eventMap[event]) this.eventMap[event] = [];\n\n    if (options.prepend) {\n      this.eventMap[event].unshift(listener);\n    } else {\n      this.eventMap[event].push(listener);\n    }\n\n    return listener;\n\n  }\n\n  /**\n   * Adds a one-time listener for the specified event. The listener will be executed once and then\n   * destroyed. It returns the [`Listener`]{@link Listener} object that was created and attached\n   * to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the first parameter. Note that a\n   * global listener will also be triggered by non-registered events.\n   *\n   * @param {string|Symbol} event The event to listen to\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the callback function in.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array and thus executed first.\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the [`arguments`]{@link Listener#arguments}\n   * property of the [`Listener`]{@link Listener} object and can be retrieved or modified as\n   * desired.\n   *\n   * @returns {Listener} The newly created [`Listener`]{@link Listener} object.\n   *\n   * @throws {TypeError} The `event` parameter must be a string or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.\n   * @throws {TypeError} The `callback` parameter must be a function.\n   */\n  addOneTimeListener(event, callback, options = {}) {\n    options.remaining = 1;\n    this.addListener(event, callback, options);\n  }\n\n  /**\n   * Identifier to use when adding or removing a listener that should be triggered when any events\n   * occur.\n   *\n   * @type {Symbol}\n   */\n  static get ANY_EVENT() {\n    return Symbol.for(\"Any event\");\n  }\n\n  /**\n   * Returns `true` if the specified event has at least one registered listener. If no event is\n   * specified, the method returns `true` if any event has at least one listener registered (this\n   * includes global listeners registered to\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}).\n   *\n   * Note: to specifically check for global listeners added with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}, use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.\n   *\n   * @param {string|Symbol} [event=(any event)] The event to check\n   * @param {function|Listener} [callback=(any callback)] The actual function that was added to the\n   * event or the {@link Listener} object returned by `addListener()`.\n   * @returns {boolean}\n   */\n  hasListener(event, callback) {\n\n    if (event === undefined) {\n\n      // Check for ANY_EVENT\n      if (\n        this.eventMap[EventEmitter.ANY_EVENT] && this.eventMap[EventEmitter.ANY_EVENT].length > 0\n      ) {\n        return true;\n      }\n\n      // Check for any regular events\n      return Object.entries(this.eventMap).some(([, value]) => {\n        return value.length > 0;\n      });\n\n    } else {\n\n      if (this.eventMap[event] && this.eventMap[event].length > 0) {\n\n        if (callback instanceof Listener) {\n          let result = this.eventMap[event].filter(listener => listener === callback);\n          return result.length > 0;\n        } else if (typeof callback === \"function\") {\n          let result = this.eventMap[event].filter(listener => listener.callback === callback);\n          return result.length > 0;\n        } else if (callback != undefined) {\n          return false;\n        }\n\n        return true;\n\n      } else {\n        return false;\n      }\n\n\n    }\n\n  }\n\n  /**\n   * An array of all the unique event names for which the emitter has at least one registered\n   * listener.\n   *\n   * Note: this excludes global events registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} because they are not tied to a\n   * specific event.\n   *\n   * @type {string[]}\n   * @readonly\n   */\n  get eventNames() {\n    return Object.keys(this.eventMap);\n  }\n\n  /**\n   * Returns an array of all the [`Listener`]{@link Listener} objects that have been registered for\n   * a specific event.\n   *\n   * Please note that global events (those added with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}) are not returned for \"regular\"\n   * events. To get the list of global listeners, specifically use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.\n   *\n   * @param {string|Symbol} event The event to get listeners for.\n   * @returns {Listener[]} An array of [`Listener`]{@link Listener} objects.\n   */\n  getListeners(event) {\n    return this.eventMap[event] || [];\n  }\n\n  /**\n   * Suspends execution of all callbacks functions registered for the specified event type.\n   *\n   * You can suspend execution of callbacks registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} by passing\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} to `suspendEvent()`. Beware that this\n   * will not suspend all callbacks but only those registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}. While this may seem counter-intuitive\n   * at first glance, it allows the selective suspension of global listeners while leaving other\n   * listeners alone. If you truly want to suspends all callbacks for a specific\n   * [`EventEmitter`]{@link EventEmitter}, simply set its `eventsSuspended` property to `true`.\n   *\n   * @param {string|Symbol} event The event name (or `EventEmitter.ANY_EVENT`) for which to suspend\n   * execution of all callback functions.\n   */\n  suspendEvent(event) {\n    this.getListeners(event).forEach(listener => {\n      listener.suspended = true;\n    });\n  }\n\n  /**\n   * Resumes execution of all suspended callback functions registered for the specified event type.\n   *\n   * You can resume execution of callbacks registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} by passing\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} to `unsuspendEvent()`. Beware that\n   * this will not resume all callbacks but only those registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}. While this may seem\n   * counter-intuitive, it allows the selective unsuspension of global listeners while leaving other\n   * callbacks alone.\n   *\n   * @param {string|Symbol} event The event name (or `EventEmitter.ANY_EVENT`) for which to resume\n   * execution of all callback functions.\n   */\n  unsuspendEvent(event) {\n    this.getListeners(event).forEach(listener => {\n      listener.suspended = false;\n    });\n  }\n\n  /**\n   * Returns the number of listeners registered for a specific event.\n   *\n   * Please note that global events (those added with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}) do not count towards the remaining\n   * number for a \"regular\" event. To get the number of global listeners, specifically use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.\n   *\n   * @param {string|Symbol} event The event which is usually a string but can also be the special\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} symbol.\n   * @returns {number} An integer representing the number of listeners registered for the specified\n   * event.\n   */\n  getListenerCount(event) {\n    return this.getListeners(event).length;\n  }\n\n  /**\n   * Executes the callback function of all the [`Listener`]{@link Listener} objects registered for\n   * a given event. The callback functions are passed the additional arguments passed to `emit()`\n   * (if any) followed by the arguments present in the [`arguments`](Listener#arguments) property of\n   * the [`Listener`](Listener) object (if any).\n   *\n   * If the [`eventsSuspended`]{@link #eventsSuspended} property is `true` or the\n   * [`Listener.suspended`]{@link Listener#suspended} property is `true`, the callback functions\n   * will not be executed.\n   *\n   * This function returns an array containing the return values of each of the callbacks.\n   *\n   * It should be noted that the regular listeners are triggered first followed by the global\n   * listeners (those added with [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}).\n   *\n   * @param {string} event The event\n   * @param {...*} args Arbitrary number of arguments to pass along to the callback functions\n   *\n   * @returns {Array} An array containing the return value of each of the executed listener\n   * functions.\n   *\n   * @throws {TypeError} The `event` parameter must be a string.\n   */\n  emit(event, ...args) {\n\n    if (typeof event !== \"string\" && !(event instanceof String)) {\n      throw new TypeError(\"The 'event' parameter must be a string.\");\n    }\n\n    if (this.eventsSuspended) return;\n\n    // We collect return values from all listeners here\n    let results = [];\n\n    // We must make sure that we do not have undefined otherwise concat() will add an undefined\n    // entry in the array.\n    let listeners = this.eventMap[EventEmitter.ANY_EVENT] || [];\n    if (this.eventMap[event]) listeners = listeners.concat(this.eventMap[event]);\n\n    listeners.forEach(listener => {\n\n      // This is the per-listener suspension check\n      if (listener.suspended) return;\n\n      let params = [...args];\n      if (Array.isArray(listener.arguments)) params = params.concat(listener.arguments);\n\n      if (listener.remaining > 0) {\n        results.push(listener.callback.apply(listener.context, params));\n        listener.count++;\n      }\n\n      if (--listener.remaining < 1) listener.remove();\n\n    });\n\n    return results;\n\n  }\n\n  /**\n   * Removes all the listeners that match the specified criterias. If no parameters are passed, all\n   * listeners will be removed. If only the `event` parameter is passed, all listeners for that\n   * event will be removed. You can remove global listeners by using\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the first parameter.\n   *\n   * To use more granular options, you must at least define the `event`. Then, you can specify the\n   * callback to match or one or more of the additional options.\n   *\n   * @param {string} [event] The event name.\n   * @param {EventEmitter~callback} [callback] Only remove the listeners that match this exact\n   * callback function.\n   * @param {Object} [options]\n   * @param {*} [options.context] Only remove the listeners that have this exact context.\n   * @param {number} [options.remaining] Only remove the listener if it has exactly that many\n   * remaining times to be executed.\n   */\n  removeListener(event, callback, options = {}) {\n\n    if (event === undefined) {\n      this.eventMap = {};\n      return;\n    } else if (!this.eventMap[event]) {\n      return;\n    }\n\n    // Find listeners that do not match the criterias (those are the ones we will keep)\n    let listeners = this.eventMap[event].filter(listener => {\n\n      return (callback && listener.callback !== callback) ||\n        (options.remaining && options.remaining !== listener.remaining) ||\n        (options.context && options.context !== listener.context);\n\n    });\n\n    if (listeners.length) {\n      this.eventMap[event] = listeners;\n    } else {\n      delete this.eventMap[event];\n    }\n\n  }\n\n  /**\n   * The `waitFor()` method is an async function which returns a promise. The promise is fulfilled\n   * when the specified event occurs. The event can be a regular event or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} (if you want to resolve as soon as any\n   * event is emitted).\n   *\n   * If the `duration` option is set, the promise will only be fulfilled if the event is emitted\n   * within the specified duration. If the event has not been fulfilled after the specified\n   * duration, the promise is rejected. This makes it super easy to wait for an event and timeout\n   * after a certain time if the event is not triggered.\n   *\n   * @param {string|Symbol} event The event to wait for\n   * @param {Object} [options={}]\n   * @param {number} [options.duration=Infinity] The number of milliseconds to wait before the\n   * promise is automatically rejected.\n   */\n  async waitFor(event, options = {}) {\n\n    options.duration = parseInt(options.duration);\n    if (isNaN(options.duration) || options.duration <= 0) options.duration = Infinity;\n\n    return new Promise((resolve, reject) => {\n\n      let timeout;\n\n      let listener = this.addListener(event, () => {\n        clearTimeout(timeout);\n        resolve();\n      }, {remaining: 1});\n\n      if (options.duration !== Infinity) {\n        timeout = setTimeout(() => {\n          listener.remove();\n          reject(\"The duration expired before the event was emitted.\");\n        }, options.duration);\n      }\n\n    });\n\n  }\n\n  /**\n   * The number of unique events that have registered listeners.\n   *\n   * Note: this excludes global events registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} because they are not tied to a\n   * specific event.\n   *\n   * @type {number}\n   * @readonly\n   */\n  get eventCount() {\n    return Object.keys(this.eventMap).length;\n  }\n\n}\n\n/**\n * The `Listener` class represents a single event listener object. Such objects keep all relevant\n * contextual information such as the event being listened to, the object the listener was attached\n * to, the callback function and so on.\n *\n */\nexport class Listener {\n\n  /**\n   * Creates a new `Listener` object\n   *\n   * @param {string|Symbol} event The event being listened to\n   * @param {EventEmitter} target The [`EventEmitter`]{@link EventEmitter} object that the listener\n   * is attached to.\n   * @param {EventEmitter~callback} callback The function to call when the listener is triggered\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=target] The context to invoke the listener in (a.k.a. the\n   * value of `this` inside the callback function).\n   * @param {number} [options.remaining=Infinity] The remaining number of times after which the\n   * callback should automatically be removed.\n   * @param {array} [options.arguments] An array of arguments that will be passed separately to the\n   * callback function upon execution. The array is stored in the [`arguments`]{@link #arguments}\n   * property and can be retrieved or modified as desired.\n   *\n   * @throws {TypeError} The `event` parameter must be a string or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.\n   * @throws {ReferenceError} The `target` parameter is mandatory.\n   * @throws {TypeError} The `callback` must be a function.\n   */\n  constructor(event, target, callback, options = {}) {\n\n    if (\n      typeof event !== \"string\" &&\n      !(event instanceof String) &&\n      event !== EventEmitter.ANY_EVENT\n    ) {\n      throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");\n    }\n\n    if (!target) {\n      throw new ReferenceError(\"The 'target' parameter is mandatory.\");\n    }\n\n    if (typeof callback !== \"function\") {\n      throw new TypeError(\"The 'callback' must be a function.\");\n    }\n\n    // Convert single value argument to array\n    if (options.arguments !== undefined && !Array.isArray(options.arguments)) {\n      options.arguments = [options.arguments];\n    }\n\n    // Define default options and merge declared options into them,\n    options = Object.assign({\n      context: target,\n      remaining: Infinity,\n      arguments: undefined,\n      duration: Infinity,\n    }, options);\n\n    // Make sure it is eventually deleted if a duration is supplied\n    if (options.duration !== Infinity) {\n      setTimeout(() => this.remove(), options.duration);\n    }\n\n    /**\n     * An array of arguments to pass to the callback function upon execution.\n     * @type {array}\n     */\n    this.arguments = options.arguments;\n\n    /**\n     * The callback function to execute.\n     * @type {Function}\n     */\n    this.callback = callback;\n\n    /**\n     * The context to execute the callback function in (a.k.a. the value of `this` inside the\n     * callback function)\n     * @type {Object}\n     */\n    this.context = options.context;\n\n    /**\n     * The number of times the listener function was executed.\n     * @type {number}\n     */\n    this.count = 0;\n\n    /**\n     * The event name.\n     * @type {string}\n     */\n    this.event = event;\n\n    /**\n     * The remaining number of times after which the callback should automatically be removed.\n     * @type {number}\n     */\n    this.remaining = parseInt(options.remaining) >= 1 ? parseInt(options.remaining) : Infinity;\n\n    /**\n     * Whether this listener is currently suspended or not.\n     * @type {boolean}\n     */\n    this.suspended = false;\n\n    /**\n     * The object that the event is attached to (or that emitted the event).\n     * @type {EventEmitter}\n     */\n    this.target = target;\n\n  }\n\n  /**\n   * Removes the listener from its target.\n   */\n  remove() {\n    this.target.removeListener(\n      this.event,\n      this.callback,\n      {context: this.context, remaining: this.remaining}\n    );\n  }\n\n}\n"],"names":["EventEmitter","constructor","eventsSuspended","this","eventMap","addListener","event","callback","options","length","String","ANY_EVENT","TypeError","listener","Listener","prepend","unshift","push","addOneTimeListener","remaining","Symbol","for","hasListener","undefined","Object","entries","some","value","filter","eventNames","keys","getListeners","suspendEvent","forEach","suspended","unsuspendEvent","getListenerCount","emit","args","results","listeners","concat","params","Array","isArray","arguments","apply","context","count","remove","removeListener","async","duration","parseInt","isNaN","Infinity","Promise","resolve","reject","timeout","clearTimeout","setTimeout","eventCount","target","ReferenceError","assign"],"mappings":"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"}