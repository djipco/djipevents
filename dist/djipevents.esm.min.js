class t{constructor(t,e,s,n={}){const i={context:this,times:1/0,data:void 0};n=Object.assign({},i,n),this.event=t,this.target=e,this.callback=s,this.context=n.context,this.times=n.times,this.data=n.data,this.suspended=!1}remove(){this.target.off(this.event,this.callback,{context:this.context,times:this.times})}}export default class{constructor(){this.events={},this.suspended=!1}on(e,s,n={}){if("function"!=typeof s)throw new TypeError("The callback must be a function");const i={context:this,times:1/0,data:void 0};n=Object.assign({},i,n);const h=new t(e,this,s,n);return this.events[e]||(this.events[e]=[]),this.events[e].push(h),h}hasListener(t){return!!(this.events[t]&&this.events[t].length>0)}get eventNames(){return Object.keys(this.events)}getListeners(t){return this.events[t]||[]}suspend(t){this.getListeners(t).forEach(t=>{t.suspended=!0})}unsuspend(t){this.getListeners(t).forEach(t=>{t.suspended=!1})}getListenerCount(t){return this.getListeners(t).length}emit(t,e){this.events[t]&&!this.suspended&&this.events[t].forEach(t=>{t.suspended||(t.times>0&&(void 0!==e?t.callback.call(t.context,e,t.data):t.callback.call(t.context,t.data)),--t.times<1&&t.remove())})}once(t,e,s={}){return s.times=1,this.on(t,e,s)}off(t,e,s={}){if(!this.events[t])return;let n=this.events[t].filter(t=>e&&t.callback!==e||s.times&&s.times!==t.times||s.context&&s.context!==t.context);n.length?this.events[t]=n:delete this.events[t]}removeAllListeners(){this.events={}}get eventCount(){return Object.keys(this.events).length}}export{t as Listener};
