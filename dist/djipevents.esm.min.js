class t{constructor(t=!1){this.map={},this.suspended=1==t}addListener(n,r,i={}){if("string"!=typeof n&&!(n instanceof String)&&n!==t.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if("function"!=typeof r)throw new TypeError("The callback must be a function.");const s=new e(n,this,r,i);return this.map[n]||(this.map[n]=[]),i.prepend?this.map[n].unshift(s):this.map[n].push(s),s}addOneTimeListener(t,e,n={}){n.remaining=1,this.addListener(t,e,n)}static get ANY_EVENT(){return Symbol.for("Any event")}hasListener(n,r){if(void 0===n)return!!(this.map[t.ANY_EVENT]&&this.map[t.ANY_EVENT].length>0)||Object.entries(this.map).some(([,t])=>t.length>0);if(this.map[n]&&this.map[n].length>0){if(r instanceof e){return this.map[n].filter(t=>t===r).length>0}if("function"==typeof r){return this.map[n].filter(t=>t.callback===r).length>0}return null==r}return!1}get eventNames(){return Object.keys(this.map)}getListeners(t){return this.map[t]||[]}suspend(t){this.getListeners(t).forEach(t=>{t.suspended=!0})}unsuspend(t){this.getListeners(t).forEach(t=>{t.suspended=!1})}getListenerCount(t){return this.getListeners(t).length}emit(e,...n){if("string"!=typeof e&&!(e instanceof String))throw new TypeError("The 'event' parameter must be a string.");if(this.suspended)return;let r=[],i=this.map[t.ANY_EVENT]||[];return this.map[e]&&(i=i.concat(this.map[e])),i.forEach(t=>{if(t.suspended)return;let e=[...n];Array.isArray(t.arguments)&&(e=e.concat(t.arguments)),t.remaining>0&&(r.push(t.callback.apply(t.context,e)),t.count++),--t.remaining<1&&t.remove()}),r}removeListener(t,e,n={}){if(void 0===t)return void(this.map={});if(!this.map[t])return;let r=this.map[t].filter(t=>e&&t.callback!==e||n.remaining&&n.remaining!==t.remaining||n.context&&n.context!==t.context);r.length?this.map[t]=r:delete this.map[t]}async waitFor(t,e={}){return e.duration=parseInt(e.duration),(isNaN(e.duration)||e.duration<=0)&&(e.duration=1/0),new Promise((n,r)=>{let i,s=this.addListener(t,()=>{clearTimeout(i),n()},{remaining:1});e.duration!==1/0&&(i=setTimeout(()=>{s.remove(),r("The duration expired before the event was emitted.")},e.duration))})}get eventCount(){return Object.keys(this.map).length}}class e{constructor(e,n,r,i={}){if("string"!=typeof e&&!(e instanceof String)&&e!==t.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if(!n)throw new ReferenceError("The 'target' parameter is mandatory.");if("function"!=typeof r)throw new TypeError("The 'callback' must be a function.");void 0===i.arguments||Array.isArray(i.arguments)||(i.arguments=[i.arguments]),(i=Object.assign({context:n,remaining:1/0,arguments:void 0,duration:1/0},i)).duration!==1/0&&setTimeout(()=>this.remove(),i.duration),this.event=e,this.target=n,this.callback=r,this.context=i.context,this.remaining=parseInt(i.remaining)>=1?parseInt(i.remaining):1/0,this.count=0,this.arguments=i.arguments,this.suspended=!1}remove(){this.target.removeListener(this.event,this.callback,{context:this.context,remaining:this.remaining})}}export{t as EventEmitter,e as Listener};
//# sourceMappingURL=djipevents.esm.min.js.map
