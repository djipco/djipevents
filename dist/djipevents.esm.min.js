class t{constructor(t=!1){this.map={},this.suspended=1==t}addListener(n,r,i={}){if("string"!=typeof n&&!(n instanceof String)&&n!==t.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if("function"!=typeof r)throw new TypeError("The callback must be a function.");const s={context:this,remaining:1/0,data:void 0,duration:1/0,prepend:!1};i=Object.assign({},s,i);const a=new e(n,this,r,i);return i.duration!==1/0&&setTimeout(()=>a.remove(),i.duration),this.map[n]||(this.map[n]=[]),i.prepend?this.map[n].unshift(a):this.map[n].push(a),a}on(t,e,n={}){return this.addListener(t,e,n)}once(t,e,n={}){return n.remaining=1,this.addListener(t,e,n)}static get ANY_EVENT(){return Symbol.for("Any event")}hasListener(e){return void 0===e?!!(this.map[t.ANY_EVENT]&&this.map[t.ANY_EVENT].length>0)||Object.entries(this.map).some(([,t])=>t.length>0):!!(this.map[e]&&this.map[e].length>0)}get eventNames(){return Object.keys(this.map)}getListeners(t){return this.map[t]||[]}suspend(t){this.getListeners(t).forEach(t=>{t.suspended=!0})}unsuspend(t){this.getListeners(t).forEach(t=>{t.suspended=!1})}getListenerCount(t){return this.getListeners(t).length}emit(e,...n){if("string"!=typeof e&&!(e instanceof String))throw new TypeError("The 'event' parameter must be a string.");if(this.suspended)return;let r=[],i=this.map[t.ANY_EVENT]||[];return this.map[e]&&(i=i.concat(this.map[e])),i.forEach(t=>{t.suspended||(t.remaining>0&&(r.push(t.callback.call(t.context,...n,t.data)),t.count++),--t.remaining<1&&t.remove())}),r}removeListener(t,e,n={}){if(!t)return void(this.map={});if(!this.map[t])return;let r=this.map[t].filter(t=>e&&t.callback!==e||n.remaining&&n.remaining!==t.remaining||n.context&&n.context!==t.context);r.length?this.map[t]=r:delete this.map[t]}off(t,e,n={}){return this.removeListener(t,e,n)}get eventCount(){return Object.keys(this.map).length}}class e{constructor(e,n,r,i={}){if("string"!=typeof e&&!(e instanceof String)&&e!==t.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if(!n)throw new ReferenceError("The 'target' parameter is mandatory.");if("function"!=typeof r)throw new TypeError("The 'callback' must be a function.");const s={context:this,remaining:1/0,data:void 0};i=Object.assign({},s,i),this.event=e,this.target=n,this.callback=r,this.context=i.context,this.remaining=parseInt(i.remaining)>=1?parseInt(i.remaining):1/0,this.count=0,this.data=i.data,this.suspended=!1}remove(){this.target.removeListener(this.event,this.callback,{context:this.context,remaining:this.remaining})}}export{t as EventEmitter,e as Listener};
//# sourceMappingURL=djipevents.esm.min.js.map
