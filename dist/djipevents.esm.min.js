class e{constructor(e=!1){this.map={},this.suspended=1==e}addListener(r,n,i={}){if("string"!=typeof r&&!(r instanceof String)&&r!==e.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if("function"!=typeof n)throw new TypeError("The callback must be a function.");const s=new t(r,this,n,i);return this.map[r]||(this.map[r]=[]),i.prepend?this.map[r].unshift(s):this.map[r].push(s),s}static get ANY_EVENT(){return Symbol.for("Any event")}hasListener(t){return void 0===t?!!(this.map[e.ANY_EVENT]&&this.map[e.ANY_EVENT].length>0)||Object.entries(this.map).some(([,e])=>e.length>0):!!(this.map[t]&&this.map[t].length>0)}get eventNames(){return Object.keys(this.map)}getListeners(e){return this.map[e]||[]}suspend(e){this.getListeners(e).forEach(e=>{e.suspended=!0})}unsuspend(e){this.getListeners(e).forEach(e=>{e.suspended=!1})}getListenerCount(e){return this.getListeners(e).length}emit(t,...r){if("string"!=typeof t&&!(t instanceof String))throw new TypeError("The 'event' parameter must be a string.");if(this.suspended)return;let n=[],i=this.map[e.ANY_EVENT]||[];return this.map[t]&&(i=i.concat(this.map[t])),i.forEach(e=>{if(e.suspended)return;let t=[...r];Array.isArray(e.arguments)&&(t=t.concat(e.arguments)),e.remaining>0&&(n.push(e.callback(...t)),e.count++),--e.remaining<1&&e.remove()}),n}removeListener(e,t,r={}){if(void 0===e)return void(this.map={});if(!this.map[e])return;let n=this.map[e].filter(e=>t&&e.callback!==t||r.remaining&&r.remaining!==e.remaining);n.length?this.map[e]=n:delete this.map[e]}get eventCount(){return Object.keys(this.map).length}}class t{constructor(t,r,n,i={}){if("string"!=typeof t&&!(t instanceof String)&&t!==e.ANY_EVENT)throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");if(!r)throw new ReferenceError("The 'target' parameter is mandatory.");if("function"!=typeof n)throw new TypeError("The 'callback' must be a function.");void 0===i.arguments||Array.isArray(i.arguments)||(i.arguments=[i.arguments]),(i=Object.assign({remaining:1/0,arguments:void 0,duration:1/0},i)).duration!==1/0&&setTimeout(()=>this.remove(),i.duration),this.event=t,this.target=r,this.callback=n,this.remaining=parseInt(i.remaining)>=1?parseInt(i.remaining):1/0,this.count=0,this.arguments=i.arguments,this.suspended=!1}remove(){this.target.removeListener(this.event,this.callback,{remaining:this.remaining})}}export{e as EventEmitter,t as Listener};
//# sourceMappingURL=djipevents.esm.min.js.map
