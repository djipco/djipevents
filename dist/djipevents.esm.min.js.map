{"version":3,"file":"djipevents.esm.min.js","sources":["../src/djipevents.js"],"sourcesContent":["/**\n * The `EventEmitter` class provides methods to implement the _observable_ design pattern. This\n * pattern allows one to _register_ a function to execute when a specific event is triggered by the\n * emitter.\n *\n * It is a mostly abstract class meant to be extended by (or mixed into) other objects.\n */\nexport class EventEmitter {\n\n  /**\n   * @param {boolean} [suspended=false] Whether the `EventEmitter` is initially in a suspended\n   * state (i.e. not executing callbacks).\n   */\n  constructor(suspended = false) {\n\n    /**\n     * An object containing a property for each event with at least one registered listener. Each\n     * event property contains an array of all the `Listener` objects registered for the event.\n     *\n     * @type {Object}\n     * @readonly\n     */\n    this.map = {};\n\n    /**\n     * Whether or not the execution of function callbacks is currently suspended for this whole\n     * emitter\n     * @type {boolean}\n     */\n    this.suspended = suspended == true ? true : false;\n\n  }\n\n  /**\n   * The callback function receives 0, 1 or 2 parameters depending on circumstances. If no specific\n   * value is passed to `emit()`, the callback is executed without any parameters. If `emit()` is\n   * called with a specific value, this value is passed along to the callback function(s). If the\n   * `data` option was specified when the listener was added, this `data` will be passed along to\n   * the callback function(s). This allows us to easily pass data from where the listener is added\n   * to where it is executed.\n   *\n   * The value of `this` in the callback function(s) is set to the `context` option passed to the\n   * `addListener()` method (if specified). By using the `context` option, it is no longer\n   * necessary to explicitely bind the function.\n   *\n   * @callback EventEmitter~callback\n   * @param {*} [value] The value passed to `emit()`\n   * @param {*} [data] The data passed in the `options` when the listener was added\n   */\n\n  /**\n   * Adds a listener for the specified event. It returns the `Listener` object that was created and\n   * attached to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use `EventEmitter.ANY_EVENT`\n   * as the first parameter. Note that a global listener will also be triggered by non-registered\n   * events. For example, this will trigger global listeners: `myEmitter.emit('bogus')`.\n   *\n   * Note that, while it is also possible to use the `on()` method to achieve the exact same result,\n   * using `addListener()` is the recommended way.\n   *\n   * @param {string|EventEmitter.ANY_EVENT} event The event to listen to\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the callback function in.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {boolean} [options.remaining=Infinity] The number of times after which the callback\n   * should automatically be removed.\n   * @param {*} [options.data] Arbitrary data to pass on to the callback function upon execution\n   *\n   * @returns {Listener} The newly created `Listener` object.\n   *\n   * @throws {TypeError} The `event` parameter must be a string or `EventEmitter.ANY_EVENT`.\n   * @throws {TypeError} The `callback` parameter must be a function.\n   */\n  addListener(event, callback, options = {}) {\n\n    if (\n      typeof event !== \"string\" &&\n      !(event instanceof String) &&\n      event !== EventEmitter.ANY_EVENT\n    ) {\n      throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");\n    }\n\n    if (typeof callback !== \"function\") throw new TypeError(\"The callback must be a function.\");\n\n    // Define default options and merge declared options into them\n    const defaults = {\n      context: this,\n      remaining: Infinity,\n      data: undefined,\n      duration: Infinity,\n      prepend: false\n    };\n    options = Object.assign({}, defaults, options);\n\n    const listener = new Listener(event, this, callback, options);\n\n    // Make sure it is eventually deleted if a duration is supplied\n    if (options.duration !== Infinity) {\n      setTimeout(() => listener.remove(), options.duration);\n    }\n\n    if (!this.map[event]) this.map[event] = [];\n\n    if (options.prepend) {\n      this.map[event].unshift(listener);\n    } else {\n      this.map[event].push(listener);\n    }\n\n    return listener;\n\n  }\n\n  /**\n   * @private\n   * @deprecated\n   */\n  on(event, callback, options = {}) {\n    return this.addListener(event, callback, options);\n  }\n\n  /**\n   * Adds a one-time listener for the specified event. It returns the `Listener` object that was\n   * created and attached to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use `EventEmitter.ANY_EVENT`\n   * as the first parameter.\n   *\n   * @param {String|EventEmitter.ANY_EVENT} event The event to listen to\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the callback function in.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {*} [options.data] Arbitrary data to pass on to the callback function upon execution\n   *\n   * @returns {Listener}\n   *\n   * @throws {TypeError} The `event` parameter must be a string or EventEmitter.ANY_EVENT.\n   * @throws {TypeError} The `callback` parameter must be a function.\n   */\n  once(event, callback, options = {}) {\n    options.remaining = 1;\n    return this.on(event, callback, options);\n  }\n\n  /**\n   * Identifier to use when trying to add or remove a listener that should be triggered when any\n   * events occur.\n   *\n   * @type {Symbol}\n   */\n  static get ANY_EVENT() {\n    return Symbol.for(\"Any event\");\n  }\n\n  /**\n   * Returns `true` if the specified event has at least one registered listener.\n   *\n   * Note: to check for global listeners added with `EventEmitter.ANY_EVENT`, use\n   * `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|EventEmitter.ANY_EVENT} event The event to check\n   * @returns {boolean}\n   */\n  hasListener(event) {\n    return (this.map[event] && this.map[event].length > 0) ? true : false;\n  }\n\n  /**\n   * An array of all the unique event names for which the emitter has at least one registered\n   * listener.\n   *\n   * Note: this excludes global events registered with `EventEmitter.ANY_EVENT` because they are not\n   * tied to a specific event.\n   *\n   * @type {string[]}\n   * @readonly\n   */\n  get eventNames() {\n    return Object.keys(this.map);\n  }\n\n  /**\n   * Returns an array of all the `Listener` objects that will be triggered for a specific event.\n   *\n   * Please note that global events (those added with `EventEmitter.ANY_EVENT`) are not returned for\n   * \"regular\" events. To get the list of global listeners, specifically use\n   * `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|EventEmitter.ANY_EVENT} event The event to get listeners for\n   * @returns {Listener[]} An array of `Listener` objects\n   */\n  getListeners(event) {\n    return this.map[event] || [];\n  }\n\n  /**\n   * Suspends execution of all callbacks functions registered for the specified event type.\n   *\n   * You can suspend execution of callbacks registered with `EventEmitter.ANY_EVENT` by passing\n   * `EventEmitter.ANY_EVENT` to `suspend()`. Beware that this will not suspend all callbacks but\n   * only those registered with `EventEmitter.ANY_EVENT`. While this may seem counter-intuitive at\n   * first glance, it allows the selective suspension of global listeners while leaving other\n   * liseners alone. If you truly want to suspends all callbacks for a specific `EventEmitter`,\n   * simply set its `suspended` property to `true`.\n   *\n   * @param {string|EventEmitter.ANY_EVENT} event The event for which to suspend execution of all\n   * callback functions.\n   */\n  suspend(event) {\n    this.getListeners(event).forEach(listener => {\n      listener.suspended = true;\n    });\n  }\n\n  /**\n   * Resumes execution of all suspended callback functions registered for the specified event type.\n   *\n   * You can resume execution of callbacks registered with `EventEmitter.ANY_EVENT` by passing\n   * `EventEmitter.ANY_EVENT` to `unsuspend()`. Beware that this will not resume all callbacks but\n   * only those registered with `EventEmitter.ANY_EVENT`. While this may seem counter-intuitive, it\n   * allows the selective unsuspension of global listeners while leaving other callbacks alone.\n   *\n   * @param {string|EventEmitter.ANY_EVENT} event The event for which to resume execution of all\n   * callback functions.\n   */\n  unsuspend(event) {\n    this.getListeners(event).forEach(listener => {\n      listener.suspended = false;\n    });\n  }\n\n  /**\n   * Returns the number of listeners registered for a specific event.\n   *\n   * Please note that global events (those added with `EventEmitter.ANY_EVENT`) do not count\n   * towards the remaining number for a \"regular\" event. To get the number of global listeners,\n   * specifically use `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|EventEmitter.ANY_EVENT} event The event\n   * @returns {number} The number of listeners registered for the specified event.\n   */\n  getListenerCount(event) {\n    return this.getListeners(event).length;\n  }\n\n  /**\n   * Executes the callback functions of all `Listener` objects registered for a given event. The\n   * functions are passed the specified `value` (if present) as the first parameter and the content\n   * of the listener's `data` property (if any).\n   *\n   * If the `suspended` property of the `EventEmitter` or of the `Listener` is `true`, the callback\n   * functions will not be executed.\n   *\n   * This function returns an array containing the return values of each of the callbacks.\n   *\n   * It should be noted that the regular listeners are triggered first followed by the global\n   * listeners (added with `EventEmitter.ANY_EVENT`).\n   *\n   * @param {string} event The event\n   * @param {*} value Arbitrary data to pass along to the callback functions\n   *\n   * @returns {Array} An array containing the return value of each of the executed listener\n   * functions\n   *\n   * @throws {TypeError} The `event` parameter must be a string.\n   */\n  emit(event, value) {\n\n    if (typeof event !== \"string\" && !(event instanceof String)) {\n      throw new TypeError(\"The 'event' parameter must be a string.\");\n    }\n\n    if (this.suspended) return;\n\n    // We collect return values for all listeners here\n    let results = [];\n\n    // We must make sure that we do not have undefined otherwise concat() will add an undefined\n    // entry in the array.\n    let listeners = this.map[EventEmitter.ANY_EVENT] || [];\n\n    if (this.map[event]) listeners = listeners.concat(this.map[event]);\n\n    listeners.forEach(listener => {\n\n      // This is the per-listener suspension check\n      if (listener.suspended) return;\n\n      if (listener.remaining > 0) {\n\n        if (value !== undefined) {\n          results.push(\n            listener.callback.call(listener.context, value, listener.data)\n          );\n        } else {\n          results.push(\n            listener.callback.call(listener.context, listener.data)\n          );\n        }\n\n        listener.count++;\n\n      }\n\n      if (--listener.remaining < 1) listener.remove();\n\n    });\n\n    return results;\n\n  }\n\n  /**\n   * Removes all the listeners that match the specified criterias. If no parameters are passed, all\n   * listeners will be removed. If only the `event` parameter is passed, all listeners for that\n   * event will be removed. You can remove global listeners by using `EventEmitter.ANY_EVENT` as the\n   * first parameter.\n   *\n   * To use more granular options, you must at least define the `event`. Then, you can specify the\n   * callback to match or one or more of the additional options.\n   *\n   * Note that, while it is also possible to use the `off()` method to achieve the exact same\n   * result, using `removeListener()` is the recommended way.\n   *\n   * @param {string} [event] The event name.\n   * @param {EventEmitter~callback} [callback] Only remove the listeners that match this exact\n   * callback function.\n   * @param {Object} [options={}]\n   * @param {*} [options.context] Only remove the listeners that have this exact context.\n   * @param {number} [options.remaining] Only remove the listener if it has exactly that many\n   * remaining times to be executed.\n   */\n  removeListener(event, callback, options = {}) {\n\n    // Remove all listeners\n    if (!event) {\n      this.map = {};\n      return;\n    }\n\n    if (!this.map[event]) return;\n\n    // Find listeners that do not match the criterias (those are the ones we will keep)\n    let events = this.map[event].filter(listener => {\n      return (callback && listener.callback !== callback) ||\n        (options.remaining && options.remaining !== listener.remaining) ||\n        (options.context && options.context !== listener.context);\n    });\n\n    if (events.length) {\n      this.map[event] = events;\n    } else {\n      delete this.map[event];\n    }\n\n  }\n\n  /**\n   * @private\n   * @deprecated\n   */\n  off(event, callback, options = {}) {\n    return this.removeListener(event, callback, options);\n  }\n\n  /**\n   * The number of unique events that have registered listeners\n   *\n   * Note: this excludes global events registered with `EventEmitter.ANY_EVENT` because they are not\n   * tied to a specific event.\n   *\n   * @type {number}\n   * @readonly\n   */\n  get eventCount() {\n    return Object.keys(this.map).length;\n  }\n\n}\n\n/**\n * The `Listener` class represents a single event listener object. Such objects keep all relevant\n * contextual information such as the event being listened to, the object the listener was attached\n * to, the callback function and so on.\n */\nexport class Listener {\n\n  /**\n   * @param {string|EventEmitter.ANY_EVENT} event The event being listened to\n   * @param {EventEmitter} target The `EventEmitter` object that the listener is attached to\n   * @param {EventEmitter~callback} callback The function to call when the listener is triggered\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the listener in (a.k.a. the value\n   * of `this` inside the callback function.\n   * @param {number} [options.remaining=Infinity] The remaining number of times after which the\n   * callback should automatically be removed.\n   * @param {*} [options.data={}] Arbitrary data to pass along to the callback function upon\n   * execution (as the second parameter)\n   *\n   * @throws {TypeError} The `event` parameter must be a string or `EventEmitter.ANY_EVENT`.\n   * @throws {ReferenceError} The `target` parameter is mandatory.\n   * @throws {TypeError} The `callback` must be a function.\n   */\n  constructor(event, target, callback, options = {}) {\n\n    if (\n      typeof event !== \"string\" &&\n      !(event instanceof String) &&\n      event !== EventEmitter.ANY_EVENT\n    ) {\n      throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");\n    }\n\n    if (!target) {\n      throw new ReferenceError(\"The 'target' parameter is mandatory.\");\n    }\n\n    if (typeof callback !== \"function\") {\n      throw new TypeError(\"The 'callback' must be a function.\");\n    }\n\n    // Define default options and merge declared options into them,\n    const defaults = {\n      context: this,\n      remaining: Infinity,\n      data: undefined\n    };\n    options = Object.assign({}, defaults, options);\n\n    /**\n     * The event name\n     * @type {string}\n     */\n    this.event = event;\n\n    /**\n     * The object that the event is attached to (or that emitted the event)\n     * @type {EventEmitter}\n     */\n    this.target = target;\n\n    /**\n     * The callback function\n     * @type {Function}\n     */\n    this.callback = callback;\n\n    /**\n     * The context to execute the context function in (a.k.a. the value of `this` inside the\n     * callback function)\n     * @type {Object}\n     */\n    this.context = options.context;\n\n    /**\n     * The remaining number of times after which the callback should automatically be removed.\n     * @type {number}\n     */\n    this.remaining = parseInt(options.remaining) >= 1 ? parseInt(options.remaining) : Infinity;\n\n    /**\n     * The number of times the listener function was executed\n     * @type {number}\n     */\n    this.count = 0;\n\n    /**\n     * Arbitraty data that is going to be passed as the second parameter of the callback function\n     * @type {*}\n     */\n    this.data = options.data;\n\n    /**\n     * Whether this listener is currently suspended\n     * @type {boolean}\n     */\n    this.suspended = false;\n\n  }\n\n  /**\n   * Removes the listener from its target.\n   */\n  remove() {\n    this.target.removeListener(\n      this.event,\n      this.callback,\n      {context: this.context, remaining: this.remaining}\n    );\n  }\n\n}\n"],"names":["EventEmitter","[object Object]","suspended","this","map","event","callback","options","String","ANY_EVENT","TypeError","defaults","context","remaining","Infinity","data","undefined","duration","prepend","Object","assign","listener","Listener","setTimeout","remove","unshift","push","addListener","on","Symbol","for","length","eventNames","keys","getListeners","forEach","value","results","listeners","concat","call","count","events","filter","removeListener","eventCount","target","ReferenceError","parseInt"],"mappings":"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"}