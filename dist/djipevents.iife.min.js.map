{"version":3,"file":"djipevents.iife.min.js","sources":["../src/djipevents.js"],"sourcesContent":["/**\n * The `EventEmitter` class provides methods to implement the _observable_ design pattern. This\n * pattern allows one to _register_ a function to execute when a specific event is triggered by the\n * emitter.\n *\n * It is a mostly abstract class meant to be extended by (or mixed into) other objects.\n */\nexport class EventEmitter {\n\n  constructor() {\n\n    /**\n     * An object containing a property for each event with at least one registered listener. Each\n     * event property contains an array of all the `Listener` objects registered for the event.\n     *\n     * @type {Object}\n     * @readonly\n     */\n    this.map = {};\n\n    /**\n     * Whether or not the execution of function callbacks is currently suspended for this whole\n     * emitter\n     * @type {boolean}\n     */\n    this.suspended = false;\n\n  }\n\n  /**\n   * The callback function receives 0, 1 or 2 parameters depending on circumstances. If no specific\n   * value is passed to `emit()`, the callback is executed without any parameters. If `emit()` is\n   * called with a specific value, this value is passed along to the callback function(s). If the\n   * `data` option was specified when the listener was added, this `data` will be passed along to\n   * the callback function(s). This allows us to easily pass data from where the listener is added\n   * to where it is executed.\n   *\n   * The value of `this` in the callbnack function(s) will be set to the `context` option (if it was\n   * specified). By using the `context` parameter, it is no longer necessary to bind the function.\n   *\n   * @callback EventEmitter~callback\n   * @param {*} [value] The value passed to `emit()`\n   * @param {*} [data] The data passed in the `options` when the listener was added\n   */\n\n  /**\n   * Adds a listener for the specified event. It returns the `Listener` object that was created and\n   * attached to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use `EventEmitter.ANY_EVENT`\n   * as the first parameter.\n   *\n   * @param {String|Symbol} event The event to listen to\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the callback function in.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {boolean} [options.count=Infinity] The number of times after which the callback should\n   * automatically be removed.\n   * @param {*} [options.data] Arbitrary data to pass on to the callback function upon execution\n   *\n   * @returns {Listener}\n   */\n  on(event, callback, options = {}) {\n\n    if (typeof callback !== \"function\") throw new TypeError(\"The callback must be a function\");\n\n    // Define default options and merge declared options into them\n    const defaults = {\n      context: this,\n      count: Infinity,\n      data: undefined,\n      duration: Infinity,\n      prepend: false\n    };\n    options = Object.assign({}, defaults, options);\n\n    const listener = new Listener(event, this, callback, options);\n\n    // Make sure it is eventually deleted if a duration is supplied\n    if (options.duration !== Infinity) {\n      setTimeout(() => listener.remove(), options.duration);\n    }\n\n    if (!this.map[event]) this.map[event] = [];\n\n    if (options.prepend) {\n      this.map[event].unshift(listener);\n    } else {\n      this.map[event].push(listener);\n    }\n\n    return listener;\n\n  }\n\n  /**\n   * Adds a one-time listener for the specified event. It returns the `Listener` object that was\n   * created and attached to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use `EventEmitter.ANY_EVENT`\n   * as the first parameter.\n   *\n   * @param {String|Symbol} event The event to listen to\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the callback function in.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {*} [options.data] Arbitrary data to pass on to the callback function upon execution\n   *\n   * @returns {Listener}\n   */\n  once(event, callback, options = {}) {\n    options.count = 1;\n    return this.on(event, callback, options);\n  }\n\n  /**\n   * Identifier to use when trying to add or remove a listener that should be triggered when any\n   * events occur.\n   *\n   * @type {Symbol}\n   */\n  static get ANY_EVENT() {\n    return Symbol.for(\"Any event\");\n  }\n\n  /**\n   * Returns `true` if the specified event has at least one registered listener.\n   *\n   * Note: to check for global listeners added with `EventEmitter.ANY_EVENT`, use\n   * `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|Symbol} event The event to check\n   * @returns {boolean}\n   */\n  hasListener(event) {\n    return (this.map[event] && this.map[event].length > 0) ? true : false;\n  }\n\n  /**\n   * An array of all the unique event names for which the emitter has at least one registered\n   * listener.\n   *\n   * Note: this excludes global events registered with `EventEmitter.ANY_EVENT` because they are not\n   * tied to a specific event.\n   *\n   * @type {string[]}\n   * @readonly\n   */\n  get eventNames() {\n    return Object.keys(this.map);\n  }\n\n  /**\n   * Returns an array of all the `Listener` objects that will be triggered for a specific event.\n   *\n   * Please note that global events (those added with `EventEmitter.ANY_EVENT`) are not returned for\n   * \"regular\" events. To get the list of global listeners, specifically use\n   * `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|Symbol} event The event to get listeners for\n   * @returns {Listener[]} An array of `Listener` objects\n   */\n  getListeners(event) {\n    return this.map[event] || [];\n  }\n\n  /**\n   * Suspends execution of all callbacks for the specified event type.\n   *\n   * Note: to suspend global listeners added with `EventEmitter.ANY_EVENT`, use\n   * `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|symbol} event The event to suspend\n   */\n  suspend(event) {\n    this.getListeners(event).forEach(listener => {\n      listener.suspended = true;\n    });\n  }\n\n  /**\n   * Resumes execution of all callbacks for the specified event type\n   *\n   * Note: to resume execution for global listeners added with `EventEmitter.ANY_EVENT`, use\n   * `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|Symbol} event The event to resume\n   */\n  unsuspend(event) {\n    this.getListeners(event).forEach(listener => {\n      listener.suspended = false;\n    });\n  }\n\n  /**\n   * Returns the number of listeners registered for a specific event.\n   *\n   * Please note that global events (those added with `EventEmitter.ANY_EVENT`) do not count\n   * towards the count for a \"regular\" event. To get the number of global listeners, specifically\n   * use `EventEmitter.ANY_EVENT` as the parameter.\n   *\n   * @param {string|Symbol} event The event\n   * @returns {number} The number of listeners registered for the specified event.\n   */\n  getListenerCount(event) {\n    return this.getListeners(event).length;\n  }\n\n  /**\n   * Executes the callback functions of all `Listener` objects registered for a given event. The\n   * functions are passed the specifid `value` (if present) and the content of the listener's\n   * `data` property (if any).\n   *\n   * If the `suspended` property of the `EventEmitter` or of the `Listener` is `true`, the callback\n   * functions will not be executed.\n   *\n   * This function returns an array containing the return values of each of the callbacks.\n   *\n   * It should be noted that the regular listeners are triggered first followed by the global\n   * listeners (added with `EventEmitter.ANY_EVENT`).\n   *\n   * @param {string|Symbol} event The event\n   * @param {*} event An arbitrary value to pass along to the callback functions\n   * @returns {Array} An array containing the return value of each of the executed listener\n   * functions\n   */\n  emit(event, value) {\n\n    // This is the global suspension check\n    if (!this.map[event]|| this.suspended) return;\n\n    // We will collect return values for all listeners here\n    let results = [];\n\n\n    // We must make sure that we do not have undefined otherwise concat() will add an undefined\n    // entry in the array.\n    let events = this.map[EventEmitter.ANY_EVENT] || [];\n    if (this.map[event]) events = events.concat(this.map[event]);\n\n    events.forEach(listener => {\n\n      // This is the per-listener suspension check\n      if (listener.suspended) return;\n\n      if (listener.count > 0) {\n\n        if (value !== undefined) {\n          results.push(\n            listener.callback.call(listener.context, value, listener.data)\n          );\n        } else {\n          results.push(\n            listener.callback.call(listener.context, listener.data)\n          );\n        }\n\n      }\n\n      if (--listener.count < 1) listener.remove();\n\n    });\n\n    return results;\n\n  }\n\n  /**\n   * Removes all the listeners that match the specified criterias. If no parameters are passed, all\n   * listeners will be removed. If only the `event` parameter is passed, all listeners for that\n   * event will be removed. You can remove global listeners by using `EventEmitter.ANY_EVENT` as the\n   * first parameter.\n   *\n   * To use more granular options, you must at least define the `event`. Then, you can specify the\n   * callback to match or one or more of the additional options.\n   *\n   * @param {string} [event] The event name.\n   * @param {EventEmitter~callback} [callback] Only remove the listeners that match this exact\n   * callback function.\n   * @param {Object} [options={}]\n   * @param {*} [options.context] Only remove the listeners that have this exact context.\n   * @param {number} [options.count] Only remove the listener if it has exactly that many remaining\n   * times to be executed.\n   */\n  off(event, callback, options = {}) {\n\n    // Remove all listeners\n    if (!event) {\n      this.map = {};\n      return;\n    }\n\n    if (!this.map[event]) return;\n\n    // Find listeners that do not match the criterias (those are the ones we will keep)\n    let events = this.map[event].filter(listener => {\n      return (callback && listener.callback !== callback) ||\n        (options.count && options.count !== listener.count) ||\n        (options.context && options.context !== listener.context);\n    });\n\n    if (events.length) {\n      this.map[event] = events;\n    } else {\n      delete this.map[event];\n    }\n\n  }\n\n  /**\n   * The number of unique events that have registered listeners\n   *\n   * Note: this excludes global events registered with `EventEmitter.ANY_EVENT` because they are not\n   * tied to a specific event.\n   *\n   * @type {number}\n   * @readonly\n   */\n  get eventCount() {\n    return Object.keys(this.map).length;\n  }\n\n}\n\n/**\n * The `Listener` class represents a single event listener object. Such objects keep all relevant\n * contextual information such as the event being listened to, the object the listener was attached\n * to, the callback function and so on.\n */\nexport class Listener {\n\n  /**\n   * @param {string|Symbol} event The event being listened to\n   * @param {EventEmitter} target The `EventEmitter` object that the listener is attached to\n   * @param {EventEmitter~callback} callback The function to call when the listener is triggered\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the listener in (a.k.a. the value\n   * of `this` inside the callback function.\n   * @param {number} [options.count=Infinity] The remaining number of times after which the\n   * callback should automatically be removed.\n   * @param {*} [options.data={}] Arbitrary data to pass along to the callback function upon\n   * execution (as the second parameter)\n   */\n  constructor(event, target, callback, options = {}) {\n\n    // Define default options and merge declared options into them,\n    const defaults = {\n      context: this,\n      count: Infinity,\n      data: undefined\n    };\n    options = Object.assign({}, defaults, options);\n\n    /**\n     * The event name\n     * @type {string}\n     */\n    this.event = event;\n\n    /**\n     * The object that the event is attached to (or that emitted the event)\n     * @type {EventEmitter}\n     */\n    this.target = target;\n\n    /**\n     * The callback function\n     * @type {Function}\n     */\n    this.callback = callback;\n\n    /**\n     * The context to execute the context function in (a.k.a. the value of `this` inside the\n     * callback function)\n     * @type {Object}\n     */\n    this.context = options.context;\n\n    /**\n     * The remaining number of times after which the callback should automatically be removed.\n     * @type {number}\n     */\n    this.count = options.count;\n\n    /**\n     * Arbitraty data that is going to be passed as the second parameter of the callback function\n     * @type {*}\n     */\n    this.data = options.data;\n\n    /**\n     * Whether this listener is currently suspended\n     * @type {boolean}\n     */\n    this.suspended = false;\n\n  }\n\n  /**\n   * Removes the listener from its target.\n   */\n  remove() {\n    this.target.off(this.event, this.callback, {context: this.context, count: this.count});\n  }\n\n}\n"],"names":["EventEmitter","map","suspended","event","callback","options","TypeError","defaults","context","this","count","Infinity","data","undefined","duration","prepend","Object","assign","listener","Listener","setTimeout","remove","unshift","push","on","length","getListeners","forEach","value","results","events","ANY_EVENT","concat","call","filter","keys","Symbol","target","off"],"mappings":"yWAOaA,EAAb,uCAWSC,IAAM,QAONC,WAAY,uCAyChBC,EAAOC,OAAUC,yDAAU,MAEJ,mBAAbD,EAAyB,MAAM,IAAIE,UAAU,uCAGlDC,EAAW,CACfC,QAASC,KACTC,MAAOC,EAAAA,EACPC,UAAMC,EACNC,SAAUH,EAAAA,EACVI,SAAS,GAEXV,EAAUW,OAAOC,OAAO,GAAIV,EAAUF,OAEhCa,EAAW,IAAIC,EAAShB,EAAOM,KAAML,EAAUC,UAGjDA,EAAQS,WAAaH,EAAAA,GACvBS,WAAW,kBAAMF,EAASG,UAAUhB,EAAQS,UAGzCL,KAAKR,IAAIE,KAAQM,KAAKR,IAAIE,GAAS,IAEpCE,EAAQU,aACLd,IAAIE,GAAOmB,QAAQJ,QAEnBjB,IAAIE,GAAOoB,KAAKL,GAGhBA,+BAuBJf,EAAOC,OAAUC,yDAAU,UAC9BA,EAAQK,MAAQ,EACTD,KAAKe,GAAGrB,EAAOC,EAAUC,uCAsBtBF,YACFM,KAAKR,IAAIE,IAAUM,KAAKR,IAAIE,GAAOsB,OAAS,wCA2BzCtB,UACJM,KAAKR,IAAIE,IAAU,mCAWpBA,QACDuB,aAAavB,GAAOwB,QAAQ,SAAAT,GAC/BA,EAAShB,WAAY,sCAYfC,QACHuB,aAAavB,GAAOwB,QAAQ,SAAAT,GAC/BA,EAAShB,WAAY,6CAcRC,UACRM,KAAKiB,aAAavB,GAAOsB,oCAqB7BtB,EAAOyB,MAGLnB,KAAKR,IAAIE,KAASM,KAAKP,eAGxB2B,EAAU,GAKVC,EAASrB,KAAKR,IAAID,EAAa+B,YAAc,UAC7CtB,KAAKR,IAAIE,KAAQ2B,EAASA,EAAOE,OAAOvB,KAAKR,IAAIE,KAErD2B,EAAOH,QAAQ,SAAAT,GAGTA,EAAShB,YAETgB,EAASR,MAAQ,SAELG,IAAVe,EACFC,EAAQN,KACNL,EAASd,SAAS6B,KAAKf,EAASV,QAASoB,EAAOV,EAASN,OAG3DiB,EAAQN,KACNL,EAASd,SAAS6B,KAAKf,EAASV,QAASU,EAASN,UAMlDM,EAASR,MAAQ,GAAGQ,EAASG,YAI9BQ,+BAqBL1B,EAAOC,OAAUC,yDAAU,MAGxBF,MAKAM,KAAKR,IAAIE,QAGV2B,EAASrB,KAAKR,IAAIE,GAAO+B,OAAO,SAAAhB,UAC1Bd,GAAYc,EAASd,WAAaA,GACvCC,EAAQK,OAASL,EAAQK,QAAUQ,EAASR,OAC5CL,EAAQG,SAAWH,EAAQG,UAAYU,EAASV,UAGjDsB,EAAOL,YACJxB,IAAIE,GAAS2B,SAEXrB,KAAKR,IAAIE,cAhBXF,IAAM,6CA3INe,OAAOmB,KAAK1B,KAAKR,+CA0KjBe,OAAOmB,KAAK1B,KAAKR,KAAKwB,kDArMtBW,WAAW,mBA3HtB,GA0UajB,EAAb,sBAcchB,EAAOkC,EAAQjC,OAAUC,yDAAU,iBAGvCE,EAAW,CACfC,QAASC,KACTC,MAAOC,EAAAA,EACPC,UAAMC,GAERR,EAAUW,OAAOC,OAAO,GAAIV,EAAUF,QAMjCF,MAAQA,OAMRkC,OAASA,OAMTjC,SAAWA,OAOXI,QAAUH,EAAQG,aAMlBE,MAAQL,EAAQK,WAMhBE,KAAOP,EAAQO,UAMfV,WAAY,kDAQZmC,OAAOC,IAAI7B,KAAKN,MAAOM,KAAKL,SAAU,CAACI,QAASC,KAAKD,QAASE,MAAOD,KAAKC,cAzEnF"}